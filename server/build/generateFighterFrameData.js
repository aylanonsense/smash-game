define([
	'fs',
	'path',
	'module',
	'build/calculateRectsFromImage',
	'json!data/fighters.json'
], function(
	fs,
	path,
	module,
	calculateRectsFromImage,
	fighters
) {
	var baseDir = path.join(path.dirname(module.uri), '/../..');

	function generateFrameDataForFighter(id, callback) {
		//get the raw frame data for the fighter
		require([ 'json!' + fighters[id].frameDataFilePath.substring(1) ], function(frameData) {
			//calculate the frame totals for each animation
			for(var state in frameData.states) {
				frameData.states[state].totalFrames = 0;
				for(var i = 0; i < frameData.states[state].animation.length; i++) {
					frameData.states[state].totalFrames += frameData.states[state].animation[i].frames;
				}
			}

			//get hurtbox data
			calculateRectsFromImage(fighters[id].hurtboxImagePath, fighters[id].sprite.frameWidth, fighters[id].sprite.frameHeight, function(hurtboxData) {
				//insert the hurtbox data into the frame data
				for(var state in frameData.states) {
					for(var i = 0; i < frameData.states[state].animation.length; i++) {
						var hurtboxFrame = frameData.states[state].animation[i].spriteFrame;
						if(typeof frameData.states[state].animation[i].hurtboxFrame === 'number') {
							hurtboxFrame = frameData.states[state].animation[i].hurtboxFrame;
							delete frameData.states[state].animation[i].hurtboxFrame;
						}
						frameData.states[state].animation[i].hurtboxes = [];
						for(var j = 0; j < hurtboxData[hurtboxFrame].length; j++) {
							frameData.states[state].animation[i].hurtboxes.push({
								x: (hurtboxData[hurtboxFrame][j].x - fighters[id].sprite.center.x) * fighters[id].sprite.scale,
								y: (hurtboxData[hurtboxFrame][j].y - fighters[id].sprite.center.y) * fighters[id].sprite.scale,
								width: hurtboxData[hurtboxFrame][j].width * fighters[id].sprite.scale,
								height: hurtboxData[hurtboxFrame][j].height * fighters[id].sprite.scale
							});
						}
					}
				}

				//get hitbox data
				calculateRectsFromImage(fighters[id].hitboxImagePath, fighters[id].sprite.frameWidth, fighters[id].sprite.frameHeight, function(hitboxData) {
					//insert the hitbox data into the frame data
					for(var state in frameData.states) {
						for(var i = 0; i < frameData.states[state].animation.length; i++) {
							var hitboxFrame = frameData.states[state].animation[i].hitboxFrame;
							if(typeof hitboxFrame !== 'undefined') {
								for(var j = 0; j < frameData.states[state].animation[i].hitboxes.length; j++) {
									var hitbox = frameData.states[state].animation[i].hitboxes[j];
									hitbox.x = (hitboxData[hitboxFrame][j].x - fighters[id].sprite.center.x) * fighters[id].sprite.scale;
									hitbox.y = (hitboxData[hitboxFrame][j].y - fighters[id].sprite.center.y) * fighters[id].sprite.scale;
									hitbox.width = hitboxData[hitboxFrame][j].width * fighters[id].sprite.scale;
									hitbox.height = hitboxData[hitboxFrame][j].height * fighters[id].sprite.scale;
									//autogenerate hitbox groups if there are none
									if(!hitbox.group) {
										hitbox.group = 'autogenerated-' + state + '-' + i + '-' + j;
									}
								}
								delete frameData.states[state].animation[i].hitboxFrame;
							}
						}
					}


					//save the compiled frame data
					fs.writeFile(path.join(baseDir, '/client/data/generated/' + id + 'FrameData.json'), JSON.stringify(frameData), function(err) {
						if(err) { throw err; }

						if(callback) {
							callback();
						}
					});
				});
			});
		});
	}

	return function generateFighterFrameData(callback) {
		//just generate the frame data for each fighter and call the callback when they're all done!
		var id, numFighters = 0, numFightersGenerated = 0;
		for(id in fighters) {
			numFighters++;
		}
		for(id in fighters) {
			generateFrameDataForFighter(id, checkForFinished);
		}
		function checkForFinished() {
			numFightersGenerated++;
			if(numFightersGenerated === numFighters && callback) {
				callback();
			}
		}
	};
});